// Javascript cookbook :
// helpful content

TO Check if it is string:

if (typeof unknownVariable === 'string' ||
    String.prototype.isPrototypeOf(unknownVariable)) {
  // It's a string primitive or a string wrapped in an object.
}
********************
TO Comapare two strings:
An alternate, bulletproof approach is to use the String.localeCompare() method with sensitivity set to accent, as shown here:
const a = "hello";
const b = "HELLO";

if (a.localeCompare(b, undefined, { sensitivity: 'accent' }) === 0) {
  // We end up here, because the case-insensitive strings match.
}
Discussion :
If localeCompare() deems that two strings match, it returns 0. Otherwise it returns a positive or negative integer indicating whether the compared string falls before or after the referenced string in the sort order. (Because we’re using localeCompare() to test for equality, the sort order isn’t important, and you can ignore it.)

The second parameter of localeCompare() holds a string that specifies the locale (as explained in “Converting a Numeric Value to a Formatted String”). If you pass undefined, then localeCompare() uses the locale of the current computer, which is almost always what you want.

To perform a case-insensitive comparison, you need to set the sensitivity property. There are two values that can work. If you set sensitivity to accent, characters that have different accents (like a and á) are treated as unequal. But if you set sensitivity to base, you’ll get a more permissive case-insensitive comparison that treats all accented letters as matches.
****************

Checking If a String Contains a Specific Substring

const searchString = 'infinitely';
const fullText = 'I know not where I was born, save that the castle was' +
 ' infinitely old and infinitely horrible.';

if (fullText.includes(searchString, 70)) {
  // Still true, because the search skips the first 'infinitely' and
  // hits the second one.
}

*******************************888
let fruits = list.split(',');
// now fruits has these elements: ['cherries', ' oranges', ' apples', ' bananas']
*********************************
    
Alternatively, you can use the String.charAt() method, which works in exactly the same way.

To get a fragment of a string, you use the slice() method. When calling slice(), you must always specify the index where you want to start your string extraction. For example, text.slice(5) starts at index position 5, continues to the end of the string, and copies that section of the text into a new string.

If you don’t want slice() to continue to the end of the string, you can supply an optional second parameter with the index where the string copying should stop:

// Get a string from index position 5 to 10.
const substring = original.slice(5, 10);


**************************************
To get the random number between MAX adn MIN values:
randomNumber = Math.floor(Math.random() * (max - min + 1) ) + min;
**********************
    CRYPTO Way to random
    Use the window.crypto property to get an instance of the Crypto object. Use the Crypto.getRandomValues() method to generate random values that have more entropy than those produced by Math.random(). (In other words, they are much less likely to be repeated or predicted—see the Discussion section for full details.)

The Crypto.getRandomValues() method works differently from Math.random(). Rather than giving you a floating-point number between 0 and 1, getRandomValues() fills an array with random integers. You can choose whether these integers are 8-bit, 16-bit, or 32-bit, and whether they are signed or unsigned. (A signed data type can be negative or positive, whereas an unsigned number is only positive.)

There is an accepted workaround to convert the output of getRandomValues() to a fractional value between 0 and 1. The trick is to divide the random value by the maximum possible number that data type can contain:

const randomBuffer = new Uint32Array(1);
window.crypto.getRandomValues(randomBuffer);
const randomFraction = randomBuffer[0] / (0xffffffff + 1);
You can now work with randomFraction in the same way that you work with the number returned from Math.random(). For example, you can convert it to a random integer in a specific range, as explained in “Generating Random Numbers”:

// Use the random fraction to make a random integer from 1-6
const randomNumber = Math.floor(randomFraction*6) + 1;
console.log(randomNumber);
If you’re running your code in the Node.js runtime environment, you won’t have access to a window object. However, you can get access to a very similar implementation of the Web Crypto API using this code:

const crypto = require('crypto').webcrypto;
Discussion
There’s a lot to unpack in this example. First, even if you don’t dig deeper into how this code works, you need to be aware of a few important details about the implementation of Crypto.getRandomValues():

Technically, Crypto creates pseudorandom numbers that are generated by a mathematical formula, like those provided by Math.random(). The difference is that these numbers are considered cryptographically strong, because the random number generator is seeded with a truly random value. The benefit of this trade-off is that getRandomValues() has similar performance to Math.random(). (It’s fast.)

There’s no way to know how the Crypto object is seeded, because that’s up to the implementation (for web page code, that means the browser manufacturer), which in turn relies on functionality in the operating system. Usually, the seed is created using a combination of recently recorded details about keyboard timings, mouse movements, and hardware readings.

No matter how good your random numbers are, if your JavaScript code is running in a browser, it’s exposed to a great number of attacks. After all, there’s nothing to stop a malicious party from seeing your code and creating an altered copy that bypasses all random number generation. If your code is running on a server, the situation is different.

Now let’s look closer at how getRandomValues() works. Before you call getRandomValues(), you must create a typed array, which is an array-like object that can only hold values of a specific data type. (We say array-like because it behaves like an array, but it isn’t an instance of the official Array type.) JavaScript provides several strongly typed array objects you can use: like Uint32Array (for an array of unsigned 32-bit integers), Uint16Array, Uint8Array, and the signed counterparts Int32Array, Int16Array, and Int8Array. You create this array to be as big as you want, and getRandomValues() will fill the whole buffer.

In this recipe, we make room for just one value in the Uint32Array:

const randomBuffer = new Uint32Array(1);
window.crypto.getRandomValues(randomBuffer);
The final step is to divide this random value by the maximum possible unsigned 32-bit integer, which is 4,294,967,295. This number is cleaner in its hexadecimal representation, 0xffffffff:

const randomFraction = randomBuffer[0] / (0xffffffff + 1);
As this code shows, you also need to add 1 to the maximum value. That’s because the random value could theoretically land exactly on the maximum integer value. If it did, the randomFraction would become 1, which differs from Math.random() and most other random number generators. (And a tiny unexpected variation from the norm is something that can lead to a incorrect assumption, and then a bug further down the road.)


****************************************************************************8

ROund the number
//You want to round a number to a certain precision (for example, 124.793 to 124.80 or 120).

const fractionalNumber = 19.48938;
const roundedNumber = Math.round(fractionalNumber);

// Now roundedNumber is 19

Chapter 3. Numbers
There are few ingredients more essential to everyday programming than numbers. Many modern languages have a set of different numeric data types to use in different scenarios, like integers, decimals, floating point values, and so on. But when it comes to numbers, JavaScript reveals its rushed, slightly improvised creation as a loosely-typed scripting language.

Until recently, JavaScript had just a single do-everything numeric data type called Number. Today, it has two: the standard Number you use almost all of the time, and the very specialized BigInt that you only consider when you need to deal with huge whole numbers. You’ll use both in this chapter, along with the utility methods of the Math object.

Generating Random Numbers
Problem
You want to generate a random whole number that falls in a set range (for example, from 1 to 6).

Solution
You can use the Math.random() method to generate a floating-point value between 0 and 1. Usually, you’ll scale this fractional value and round it, so you end up with an integer in a specific range. Assuming your range spans from some minimum number min to a maximum number max, here’s the statement you need:

randomNumber = Math.floor(Math.random() * (max - min + 1) ) + min;
For example, if you want to pick a random number between 1 and 6, the code becomes:

const randomNumber = Math.floor(Math.random()*6) + 1;
Now possible values of randomNumber are 1, 2, 3, 4, 5, or 6.

Discussion
The Math object is stocked full of static utility methods you can call at any time. This recipe uses Math.random() to get a random fractional number, and Math.floor() to truncate the decimal portion, leaving you with an integer.

To understand how this works, let’s consider a sample run-through. First, Math.random() picks a value between 0 and 1, like 0.374324823:

const randomNumber = Math.floor(0.374324823*6) + 1;
That number is multiplied by the number of values in your range (in this example, 6), becoming 2.245948938:

const randomNumber = Math.floor(2.245948938) + 1;
Then the Math.floor() function truncates this to just 2:

const randomNumber = 2 + 1;
Finally, the starting number of the range is added, giving the final result of 3. Repeat this calculation and you’ll get a different number, but it will always be an integer from the range we’ve set of 1 to 6.

See Also
The Math.floor() method is only one way to round numbers. See “Rounding to a Specific Decimal Place” for more.

It’s important to understand that numbers generated by Math.random() are pseudorandom, which means they can be guessed or reverse engineered. They are not random enough for cryptography, lotteries, or complex modelling. For more about the difference, see “Generating Cryptographically Secure Random Numbers”. And if you need a way to generate a repeatable sequence of pseudorandom numbers, refer to “Extra: Building a Repeatable Pseudorandom Number Generator”.

Generating Cryptographically Secure Random Numbers
Problem
You want to create a random number that can’t be easily reverse engineered (guessed).

Solution
Use the window.crypto property to get an instance of the Crypto object. Use the Crypto.getRandomValues() method to generate random values that have more entropy than those produced by Math.random(). (In other words, they are much less likely to be repeated or predicted—see the Discussion section for full details.)

The Crypto.getRandomValues() method works differently from Math.random(). Rather than giving you a floating-point number between 0 and 1, getRandomValues() fills an array with random integers. You can choose whether these integers are 8-bit, 16-bit, or 32-bit, and whether they are signed or unsigned. (A signed data type can be negative or positive, whereas an unsigned number is only positive.)

There is an accepted workaround to convert the output of getRandomValues() to a fractional value between 0 and 1. The trick is to divide the random value by the maximum possible number that data type can contain:

const randomBuffer = new Uint32Array(1);
window.crypto.getRandomValues(randomBuffer);
const randomFraction = randomBuffer[0] / (0xffffffff + 1);
You can now work with randomFraction in the same way that you work with the number returned from Math.random(). For example, you can convert it to a random integer in a specific range, as explained in “Generating Random Numbers”:

// Use the random fraction to make a random integer from 1-6
const randomNumber = Math.floor(randomFraction*6) + 1;
console.log(randomNumber);
If you’re running your code in the Node.js runtime environment, you won’t have access to a window object. However, you can get access to a very similar implementation of the Web Crypto API using this code:

const crypto = require('crypto').webcrypto;
Discussion
There’s a lot to unpack in this example. First, even if you don’t dig deeper into how this code works, you need to be aware of a few important details about the implementation of Crypto.getRandomValues():

Technically, Crypto creates pseudorandom numbers that are generated by a mathematical formula, like those provided by Math.random(). The difference is that these numbers are considered cryptographically strong, because the random number generator is seeded with a truly random value. The benefit of this trade-off is that getRandomValues() has similar performance to Math.random(). (It’s fast.)

There’s no way to know how the Crypto object is seeded, because that’s up to the implementation (for web page code, that means the browser manufacturer), which in turn relies on functionality in the operating system. Usually, the seed is created using a combination of recently recorded details about keyboard timings, mouse movements, and hardware readings.

No matter how good your random numbers are, if your JavaScript code is running in a browser, it’s exposed to a great number of attacks. After all, there’s nothing to stop a malicious party from seeing your code and creating an altered copy that bypasses all random number generation. If your code is running on a server, the situation is different.

Now let’s look closer at how getRandomValues() works. Before you call getRandomValues(), you must create a typed array, which is an array-like object that can only hold values of a specific data type. (We say array-like because it behaves like an array, but it isn’t an instance of the official Array type.) JavaScript provides several strongly typed array objects you can use: like Uint32Array (for an array of unsigned 32-bit integers), Uint16Array, Uint8Array, and the signed counterparts Int32Array, Int16Array, and Int8Array. You create this array to be as big as you want, and getRandomValues() will fill the whole buffer.

In this recipe, we make room for just one value in the Uint32Array:

const randomBuffer = new Uint32Array(1);
window.crypto.getRandomValues(randomBuffer);
The final step is to divide this random value by the maximum possible unsigned 32-bit integer, which is 4,294,967,295. This number is cleaner in its hexadecimal representation, 0xffffffff:

const randomFraction = randomBuffer[0] / (0xffffffff + 1);
As this code shows, you also need to add 1 to the maximum value. That’s because the random value could theoretically land exactly on the maximum integer value. If it did, the randomFraction would become 1, which differs from Math.random() and most other random number generators. (And a tiny unexpected variation from the norm is something that can lead to a incorrect assumption, and then a bug further down the road.)

Rounding to a Specific Decimal Place
Problem
You want to round a number to a certain precision (for example, 124.793 to 124.80 or 120).

Solution
You can use the Math.round() method to round a number to the nearest whole number:

const fractionalNumber = 19.48938;
const roundedNumber = Math.round(fractionalNumber);

// Now roundedNumber is 19
Oddly enough, the round() method doesn’t take an argument that lets you specify a number of decimal places to keep. If you want a different degree of precision, it’s up to you to multiply your number by the appropriate power of 10, round it, and then divide it by the same power of 10 after rounding. Here’s the general formula for this operation:

const numberToRound = fractionalNumber * (10**numberOfDecimalPlaces);
let roundedNumber = Math.round(numberToRound);
roundedNumber = roundedNumber / (10**numberOfDecimalPlaces);
const fractionalNumber = 19.48938;
const numberToRound = fractionalNumber * (10**2);
let roundedNumber = Math.round(numberToRound);
roundedNumber = roundedNumber / (10**2);

// Now roundedNumber is 19.49

  
  
  
